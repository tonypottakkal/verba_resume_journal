"""
ResumeExporter module for exporting resumes to various formats.

This module provides functionality to export resumes to PDF, DOCX, and Markdown formats
with professional styling and formatting.
"""

from wasabi import msg
from typing import Optional
from io import BytesIO
import re
from datetime import datetime

# PDF export dependencies
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_JUSTIFY
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak
from reportlab.lib.colors import HexColor
from reportlab.pdfgen import canvas

# DOCX export dependencies
from docx import Document
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH

# Markdown processing
import markdown
from markdownify import markdownify as md


class ResumeExporter:
    """
    Exports resumes to various formats (PDF, DOCX, Markdown).
    
    Provides methods to convert resume content to professionally formatted
    documents with consistent styling across formats.
    """
    
    def __init__(
        self,
        page_size: str = "letter",
        font_name: str = "Helvetica",
        base_font_size: int = 11
    ):
        """
        Initialize ResumeExporter.
        
        Args:
            page_size: Page size for PDF export ("letter" or "a4")
            font_name: Base font name for PDF export
            base_font_size: Base font size in points
        """
        self.page_size = letter if page_size.lower() == "letter" else A4
        self.font_name = font_name
        self.base_font_size = base_font_size
        msg.good(f"ResumeExporter initialized with {page_size} page size")
    
    def export_to_pdf(
        self,
        content: str,
        title: Optional[str] = None,
        author: Optional[str] = None
    ) -> bytes:
        """
        Export resume content to PDF format.
        
        Args:
            content: Resume content in markdown format
            title: Optional document title
            author: Optional author name
            
        Returns:
            bytes: PDF file content
            
        Raises:
            Exception: If PDF generation fails
        """
        try:
            msg.info("Generating PDF resume...")
            
            # Create PDF buffer
            buffer = BytesIO()
            
            # Create PDF document
            doc = SimpleDocTemplate(
                buffer,
                pagesize=self.page_size,
                rightMargin=0.75 * inch,
                leftMargin=0.75 * inch,
                topMargin=0.75 * inch,
                bottomMargin=0.75 * inch,
                title=title or "Resume",
                author=author or "Generated by Local Resume System"
            )
            
            # Build story (content elements)
            story = []
            styles = self._create_pdf_styles()
            
            # Parse markdown content and convert to PDF elements
            sections = self._parse_markdown_content(content)
            
            for section in sections:
                section_type = section.get("type")
                section_content = section.get("content", "")
                
                if section_type == "heading1":
                    # Main heading (name)
                    para = Paragraph(section_content, styles["ResumeHeading1"])
                    story.append(para)
                    story.append(Spacer(1, 0.2 * inch))
                    
                elif section_type == "heading2":
                    # Section heading
                    story.append(Spacer(1, 0.15 * inch))
                    para = Paragraph(section_content, styles["ResumeHeading2"])
                    story.append(para)
                    story.append(Spacer(1, 0.1 * inch))
                    
                elif section_type == "heading3":
                    # Subsection heading
                    para = Paragraph(section_content, styles["ResumeHeading3"])
                    story.append(para)
                    story.append(Spacer(1, 0.05 * inch))
                    
                elif section_type == "bullet":
                    # Bullet point
                    para = Paragraph(f"â€¢ {section_content}", styles["ResumeBullet"])
                    story.append(para)
                    
                elif section_type == "paragraph":
                    # Regular paragraph
                    if section_content.strip():
                        para = Paragraph(section_content, styles["ResumeNormal"])
                        story.append(para)
                        story.append(Spacer(1, 0.05 * inch))
            
            # Build PDF
            doc.build(story)
            
            # Get PDF bytes
            pdf_bytes = buffer.getvalue()
            buffer.close()
            
            msg.good(f"Generated PDF resume ({len(pdf_bytes)} bytes)")
            return pdf_bytes
            
        except Exception as e:
            msg.fail(f"Failed to generate PDF: {str(e)}")
            raise Exception(f"Failed to generate PDF: {str(e)}")
    
    def _create_pdf_styles(self):
        """Create custom styles for PDF generation."""
        styles = getSampleStyleSheet()
        
        # Resume Heading 1 - Name/Title
        styles.add(ParagraphStyle(
            name='ResumeHeading1',
            fontName=f'{self.font_name}-Bold',
            fontSize=self.base_font_size + 8,
            textColor=HexColor('#1a1a1a'),
            spaceAfter=6,
            alignment=TA_CENTER,
            leading=self.base_font_size + 10
        ))
        
        # Resume Heading 2 - Section headers
        styles.add(ParagraphStyle(
            name='ResumeHeading2',
            fontName=f'{self.font_name}-Bold',
            fontSize=self.base_font_size + 3,
            textColor=HexColor('#2c3e50'),
            spaceAfter=6,
            spaceBefore=12,
            borderWidth=0,
            borderPadding=0,
            borderColor=HexColor('#2c3e50'),
            borderRadius=None,
            leading=self.base_font_size + 5
        ))
        
        # Resume Heading 3 - Subsection headers
        styles.add(ParagraphStyle(
            name='ResumeHeading3',
            fontName=f'{self.font_name}-Bold',
            fontSize=self.base_font_size + 1,
            textColor=HexColor('#34495e'),
            spaceAfter=4,
            spaceBefore=8,
            leading=self.base_font_size + 3
        ))
        
        # Resume Normal text
        styles.add(ParagraphStyle(
            name='ResumeNormal',
            fontName=self.font_name,
            fontSize=self.base_font_size,
            textColor=HexColor('#333333'),
            alignment=TA_JUSTIFY,
            leading=self.base_font_size + 3
        ))
        
        # Resume Bullet points
        styles.add(ParagraphStyle(
            name='ResumeBullet',
            parent=styles['ResumeNormal'],
            fontName=self.font_name,
            fontSize=self.base_font_size,
            textColor=HexColor('#333333'),
            leftIndent=20,
            spaceAfter=4,
            leading=self.base_font_size + 3
        ))
        
        return styles
    
    def _parse_markdown_content(self, content: str) -> list:
        """
        Parse markdown content into structured sections.
        
        Args:
            content: Markdown formatted resume content
            
        Returns:
            List of section dictionaries with type and content
        """
        sections = []
        lines = content.split('\n')
        
        for line in lines:
            line = line.strip()
            
            if not line:
                continue
            
            # Check for headings
            if line.startswith('# '):
                sections.append({
                    "type": "heading1",
                    "content": self._clean_markdown(line[2:])
                })
            elif line.startswith('## '):
                sections.append({
                    "type": "heading2",
                    "content": self._clean_markdown(line[3:])
                })
            elif line.startswith('### '):
                sections.append({
                    "type": "heading3",
                    "content": self._clean_markdown(line[4:])
                })
            # Check for bullet points
            elif line.startswith('- ') or line.startswith('* '):
                sections.append({
                    "type": "bullet",
                    "content": self._clean_markdown(line[2:])
                })
            # Regular paragraph
            else:
                sections.append({
                    "type": "paragraph",
                    "content": self._clean_markdown(line)
                })
        
        return sections
    
    def _clean_markdown(self, text: str) -> str:
        """
        Clean markdown formatting from text for PDF rendering.
        
        Args:
            text: Text with markdown formatting
            
        Returns:
            Cleaned text suitable for PDF
        """
        # Remove bold markers
        text = re.sub(r'\*\*(.+?)\*\*', r'<b>\1</b>', text)
        text = re.sub(r'__(.+?)__', r'<b>\1</b>', text)
        
        # Remove italic markers
        text = re.sub(r'\*(.+?)\*', r'<i>\1</i>', text)
        text = re.sub(r'_(.+?)_', r'<i>\1</i>', text)
        
        # Remove code markers
        text = re.sub(r'`(.+?)`', r'<font name="Courier">\1</font>', text)
        
        # Remove links but keep text
        text = re.sub(r'\[(.+?)\]\(.+?\)', r'\1', text)
        
        return text
    
    def export_to_docx(
        self,
        content: str,
        title: Optional[str] = None,
        author: Optional[str] = None
    ) -> bytes:
        """
        Export resume content to DOCX format.
        
        Args:
            content: Resume content in markdown format
            title: Optional document title
            author: Optional author name
            
        Returns:
            bytes: DOCX file content
            
        Raises:
            Exception: If DOCX generation fails
        """
        try:
            msg.info("Generating DOCX resume...")
            
            # Create document
            doc = Document()
            
            # Set document properties
            if title:
                doc.core_properties.title = title
            if author:
                doc.core_properties.author = author
            doc.core_properties.created = datetime.now()
            
            # Configure document margins
            sections = doc.sections
            for section in sections:
                section.top_margin = Inches(0.75)
                section.bottom_margin = Inches(0.75)
                section.left_margin = Inches(0.75)
                section.right_margin = Inches(0.75)
            
            # Parse markdown content
            parsed_sections = self._parse_markdown_content(content)
            
            for section in parsed_sections:
                section_type = section.get("type")
                section_content = section.get("content", "")
                
                if section_type == "heading1":
                    # Main heading (name)
                    heading = doc.add_heading(self._strip_html(section_content), level=1)
                    heading.alignment = WD_ALIGN_PARAGRAPH.CENTER
                    # Style the heading
                    for run in heading.runs:
                        run.font.size = Pt(self.base_font_size + 8)
                        run.font.color.rgb = RGBColor(26, 26, 26)
                        run.font.bold = True
                    
                elif section_type == "heading2":
                    # Section heading
                    heading = doc.add_heading(self._strip_html(section_content), level=2)
                    # Style the heading
                    for run in heading.runs:
                        run.font.size = Pt(self.base_font_size + 3)
                        run.font.color.rgb = RGBColor(44, 62, 80)
                        run.font.bold = True
                    
                elif section_type == "heading3":
                    # Subsection heading
                    heading = doc.add_heading(self._strip_html(section_content), level=3)
                    # Style the heading
                    for run in heading.runs:
                        run.font.size = Pt(self.base_font_size + 1)
                        run.font.color.rgb = RGBColor(52, 73, 94)
                        run.font.bold = True
                    
                elif section_type == "bullet":
                    # Bullet point
                    para = doc.add_paragraph(style='List Bullet')
                    self._add_formatted_text(para, section_content)
                    
                elif section_type == "paragraph":
                    # Regular paragraph
                    if section_content.strip():
                        para = doc.add_paragraph()
                        self._add_formatted_text(para, section_content)
            
            # Save to buffer
            buffer = BytesIO()
            doc.save(buffer)
            docx_bytes = buffer.getvalue()
            buffer.close()
            
            msg.good(f"Generated DOCX resume ({len(docx_bytes)} bytes)")
            return docx_bytes
            
        except Exception as e:
            msg.fail(f"Failed to generate DOCX: {str(e)}")
            raise Exception(f"Failed to generate DOCX: {str(e)}")
    
    def _add_formatted_text(self, paragraph, text: str):
        """
        Add formatted text to a DOCX paragraph, handling HTML-like tags.
        
        Args:
            paragraph: DOCX paragraph object
            text: Text with HTML-like formatting tags
        """
        # Set base font
        paragraph.style.font.name = 'Calibri'
        paragraph.style.font.size = Pt(self.base_font_size)
        
        # Parse and add text with formatting
        parts = re.split(r'(<b>.*?</b>|<i>.*?</i>|<font.*?>.*?</font>)', text)
        
        for part in parts:
            if not part:
                continue
            
            if part.startswith('<b>') and part.endswith('</b>'):
                # Bold text
                run = paragraph.add_run(part[3:-4])
                run.font.bold = True
                run.font.size = Pt(self.base_font_size)
                
            elif part.startswith('<i>') and part.endswith('</i>'):
                # Italic text
                run = paragraph.add_run(part[3:-4])
                run.font.italic = True
                run.font.size = Pt(self.base_font_size)
                
            elif part.startswith('<font') and part.endswith('</font>'):
                # Code/monospace text
                content = re.sub(r'<font.*?>(.*?)</font>', r'\1', part)
                run = paragraph.add_run(content)
                run.font.name = 'Courier New'
                run.font.size = Pt(self.base_font_size - 1)
                
            else:
                # Regular text
                run = paragraph.add_run(part)
                run.font.size = Pt(self.base_font_size)
    
    def _strip_html(self, text: str) -> str:
        """
        Strip HTML-like tags from text.
        
        Args:
            text: Text with HTML-like tags
            
        Returns:
            Plain text without tags
        """
        # Remove all HTML-like tags
        text = re.sub(r'<[^>]+>', '', text)
        return text
    
    def export_to_markdown(self, content: str) -> bytes:
        """
        Export resume content to Markdown format.
        
        Args:
            content: Resume content in markdown format
            
        Returns:
            bytes: Markdown file content as UTF-8 bytes
        """
        try:
            msg.info("Exporting resume as Markdown...")
            markdown_bytes = content.encode('utf-8')
            msg.good(f"Exported Markdown resume ({len(markdown_bytes)} bytes)")
            return markdown_bytes
            
        except Exception as e:
            msg.fail(f"Failed to export Markdown: {str(e)}")
            raise Exception(f"Failed to export Markdown: {str(e)}")
